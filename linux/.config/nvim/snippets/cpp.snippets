snippet bits "CP template without testcase number"
	#include <bits/stdc++.h>
	#include <ext/pb_ds/assoc_container.hpp>
	#include <ext/pb_ds/tree_policy.hpp>
	using namespace std;
	using namespace __gnu_pbds;
	template<class T> using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;
	#define M_PI 3.14159265358979323846
	#define MOD 1000000007
	#define INF 1000000005
	#define NEG_INF -1000000005
	#define sz(x) (int)x.size()
	#define all(x) x.begin(), x.end()
	typedef long long ll;
	typedef vector<int> vint;
	typedef vector<vint> vvint;
	typedef vector<ll> vll;
	typedef vector<vll> vvll;
	typedef pair<int, int> ipair;
	typedef pair<ll, ll> llpair;

	void __print(int x) {cerr << x;}
	void __print(long x) {cerr << x;}
	void __print(long long x) {cerr << x;}
	void __print(unsigned x) {cerr << x;}
	void __print(unsigned long x) {cerr << x;}
	void __print(unsigned long long x) {cerr << x;}
	void __print(float x) {cerr << x;}
	void __print(double x) {cerr << x;}
	void __print(long double x) {cerr << x;}
	void __print(char x) {cerr << '\'' << x << '\'';}
	void __print(const char *x) {cerr << '\"' << x << '\"';}
	void __print(const string &x) {cerr << '\"' << x << '\"';}
	void __print(bool x) {cerr << (x ? "true" : "false");}

	template<typename T, typename V>
	void __print(const pair<T, V> &x) {cerr << '{'; __print(x.first); cerr << ','; __print(x.second); cerr << '}';}
	template<typename T>
	void __print(const T &x) {int f = 0; cerr << '{'; for (auto &i: x) cerr << (f++ ? "," : ""), __print(i); cerr << "}";}
	void _print() {cerr << "]\n";}
	template <typename T, typename... V>
	void _print(T t, V... v) {__print(t); if (sizeof...(v)) cerr << ", "; _print(v...);}
	#ifndef ONLINE_JUDGE
	#define debug(x...) cerr << "[" << #x << "] = ["; _print(x)
	#else
	#define debug(x...)
	#endif

	/*
		Author: Koushik Sahu
	*/

	void solve(){
		${2}
	}

	int main(){
		ios_base::sync_with_stdio(false);
		cin.tie(NULL);
		int T=1;
		//cin>>T;${1}
		while(T--){
			solve();
		}
		return 0;
	}

snippet cp "CP tempate with testcase numbers"
	#include <bits/stdc++.h>
	#include <ext/pb_ds/assoc_container.hpp>
	#include <ext/pb_ds/tree_policy.hpp>
	using namespace std;
	using namespace __gnu_pbds;
	template<class T> using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;
	#define M_PI 3.14159265358979323846
	#define MOD 1000000007
	#define INF 1000000005
	#define NEG_INF -1000000005
	#define sz(x) (int)x.size()
	#define all(x) x.begin(), x.end()
	typedef long long ll;
	typedef vector<int> vint;
	typedef vector<vint> vvint;
	typedef vector<ll> vll;
	typedef vector<vll> vvll;
	typedef pair<int, int> ipair;
	typedef pair<ll, ll> llpair;

	void __print(int x) {cerr << x;}
	void __print(long x) {cerr << x;}
	void __print(long long x) {cerr << x;}
	void __print(unsigned x) {cerr << x;}
	void __print(unsigned long x) {cerr << x;}
	void __print(unsigned long long x) {cerr << x;}
	void __print(float x) {cerr << x;}
	void __print(double x) {cerr << x;}
	void __print(long double x) {cerr << x;}
	void __print(char x) {cerr << '\'' << x << '\'';}
	void __print(const char *x) {cerr << '\"' << x << '\"';}
	void __print(const string &x) {cerr << '\"' << x << '\"';}
	void __print(bool x) {cerr << (x ? "true" : "false");}

	template<typename T, typename V>
	void __print(const pair<T, V> &x) {cerr << '{'; __print(x.first); cerr << ','; __print(x.second); cerr << '}';}
	template<typename T>
	void __print(const T &x) {int f = 0; cerr << '{'; for (auto &i: x) cerr << (f++ ? "," : ""), __print(i); cerr << "}";}
	void _print() {cerr << "]\n";}
	template <typename T, typename... V>
	void _print(T t, V... v) {__print(t); if (sizeof...(v)) cerr << ", "; _print(v...);}
	#ifndef ONLINE_JUDGE
	#define debug(x...) cerr << "[" << #x << "] = ["; _print(x)
	#else
	#define debug(x...)
	#endif

	/*
		Author: Koushik Sahu
	*/

	void solve(){
		${2}
	}

	int main(){
		ios_base::sync_with_stdio(false);
		cin.tie(NULL);
		int T=1;
		//cin>>T;${1}
		for(int i=1; i<=T; i++){
			cout<<"Case #"<<i<<": ";
			solve();
		}
		return 0;
	}

snippet gen "generator program for making stress test testcases"
	#include <bits/stdc++.h>
	#include <ext/pb_ds/assoc_container.hpp>
	#include <ext/pb_ds/tree_policy.hpp>
	using namespace std;
	using namespace __gnu_pbds;
	template<class T> using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;

	/*
		Author: Koushik Sahu
	*/

	int rand(int a, int b){
		return a + rand()%(b-a+1);
	}

	int main(int argc, char* argv[]){
		srand(atoi(argv[1]));
		${1}
		return 0;
	}

snippet combinatorics "useful combinatorics algorithms"
	class Combinatorics{
		public:
			Combinatorics(int mod) : mod(mod) {
				precomputeInverse();
				precomputeFactorialInverse();
				precomputeFactorial();
			}

			ll factorial(int x){
				assert(x<N);
				return fact[x];
			}

			ll inverse_factorial(int x){
				assert(x<N);
				return fact_inverse[x];
			}

			ll nCr(ll n, ll r){
				if(r>n) return 0;
				assert(n<N && r<N);
				ll ans = (((fact[n]*fact_inverse[r])%mod)*fact_inverse[n-r])%mod;
				return ans;
			}

			ll nPr(ll n, ll r){
				if(r>n) return 0;
				assert(n<N && r<N);
				ll ans = (fact[n]*fact_inverse[n-r])%mod;
				return ans;
			}

		private:
			int mod;
			static const int N=1e6+5;
			array<ll, N> fact, inverse, fact_inverse;

			void precomputeInverse(){
				inverse[0] = inverse[1] = 1;
				for(int i=2; i<N; i++) inverse[i] = inverse[mod%i]*(mod - mod/i)%mod;
			}

			void precomputeFactorialInverse(){
				fact_inverse[0] = fact_inverse[1] = 1;
				for(int i=2; i<N; i++) fact_inverse[i] = (fact_inverse[i-1]*inverse[i])%mod;
			}

			void precomputeFactorial(){
				fact[0] = 1;
				for(int i=1; i<N; i++) fact[i] = (i*fact[i-1])%mod; 
			}
	};

snippet segmenttree "segment tree implementation for CP"
	template <typename T>
	class SegmentTree {
		public:
	    SegmentTree(int len, T* arr, function<T(T, T)> func, T init) : n(len), fn(func), init(init) {
	      st.resize(2*len);
	      for(int i=len; i<2*len; i++) st[i] = arr[i-len];
	      build();
	    }

	    SegmentTree(int len, vector<T> arr, function<T(T, T)> func, T init) : n(len), fn(func), init(init) {
	      st.resize(2*len);
	      for(int i=len; i<2*len; i++) st[i] = arr[i-len];
	      build();
	    }

	    void update(size_t idx, T val){
	      for(st[idx+=n]=val; idx>1; idx>>=1) st[idx>>1] = fn(st[idx], st[idx^1]);
	    }

	    T query(size_t l, size_t r){
	      r++;
	      T res = init;
	      for(l+=n, r+=n; l<r; l>>=1, r>>=1){
		if(l&1) res = fn(res, st[l++]);
		if(r&1) res = fn(res, st[--r]);
	      }
	      return res;
	    }

	  private:
	    size_t n;
	    T init;
	    vector<T> st;
	    function<T(T, T)> fn;

	    void build(){
	      for(int i=n-1; i>0; i--) st[i] = fn(st[i<<1], st[(i<<1)|1]);
	    }

	};

snippet sparsetable "spare table implementation for CP"
	template<class T>
	class SparseTable{
		public:
			SparseTable(size_t len, T* arr, function<T(T, T)> func){
				n = len;
				fn = func;
	      a.resize(n);
	      for(int i=0; i<n; i++) a[i] = arr[i];
	      st.resize(n);
	      for(int i=0; i<n; i++) st[i] = vector<T>(K, 0);
				build();
			}
	    
	    SparseTable(size_t len, vector<T> arr, function<T(T, T)> func){
				n = len;
				fn = func;
	      a.resize(n);
	      for(int i=0; i<n; i++) a[i] = arr[i];
	      st.resize(n);
	      for(int i=0; i<n; i++) st = vector<int>(K, 0);
				build();
	    }

			T query(int l, int r){
	      assert(l<=r);
				int j = log2(r-l+1);
				return fn(st[l][j], st[r-(1<<j)+1][j]);
			}

		private:
	    static const int K = 25;
			int n;
	    vector<T> a;
	    function<T(T, T)> fn;
	    vector<vector<T>> st;

			void build(){
				for(int i=0; i<n; i++) st[i][0] = a[i];
				for(int j=1; j<=K; j++){
					for(int i=0; i+(1<<j)-1<n; i++){
						st[i][j] = fn(st[i][j-1], st[i+(1<<(j-1))][j-1]);
					}
				}
			}
	};

snippet scc "strongly connected components implementation for CP"
	void dfs_order(int u, vector<int>* g, bool* seen, vector<int>& order){
	  seen[u] = true;
	  for(int v: g[u]){
	    if(!seen[v]) dfs_order(v, g, seen, order);
	  }
	  order.push_back(u);
	}

	void dfs_scc(int u, vector<int>* gr, bool* seen, vector<int>& scc){
	  seen[u] = true;
	  scc.push_back(u);
	  for(int v: gr[u]){
	    if(!seen[v]) dfs_scc(v, gr, seen, scc);
	  }
	}

	vector<vector<int>> scc(int n, vector<int>* g, vector<int>* gr){
	  vector<int> order;
	  bool seen[n];
	  fill(seen, seen+n, false);
	  for(int i=0; i<n; i++){
	    if(!seen[i]) dfs_order(i, g, seen, order);
	  }
	  reverse(order.begin(), order.end());
	  fill(seen, seen+n, false);
	  vector<vector<int>> sccs;
	  for(int i: order){
	    if(!seen[i]){
	      vector<int> scc;
	      dfs_scc(i, gr, seen, scc);
	      sccs.push_back(scc);
	    }
	  }
	  return sccs;
	}

snippet matrix "helper class for matrices for CP"
	template <typename T>
	class Row{
		public:
			Row(){ }

			Row(int len) : n(len){
				assert(len>0);
				n = len;
				a = new int[len];
				for(int i=0; i<len; i++) a[i] = 0;
			}

			T& operator[](int idx){
				assert(idx>=0 && idx<n);
				return a[idx];
			}

			int size(){
				return n;
			}

		private:
			T* a;
			int n;

	};

	template <typename T>
	class Matrix{
		public:
			int n, m;

			Matrix(int row, int col, bool identity=false) : n(row), m(col){
				if(identity) assert(row == col);
				a = new Row<T>[row];
				for(int i=0; i<row; i++) a[i] = Row<T>(col);
				if(identity) for(int i=0; i<row; i++) a[i][i] = 1;
			}

			Row<T>& operator[](int idx){
				return a[idx];
			}

			Matrix operator*(Matrix b){
				assert(m == b.n);
				Matrix<T> product(n, b.m);
				for(int i=0; i<n; i++){
					for(int j=0; j<b.m; j++){
						for(int k=0; k<m; k++){
							product[i][j] += (a[i][k]*b[k][j]);
						}
					}
				}
				return product;
			}

			void show(){
				for(int i=0; i<n; i++){
					for(int j=0; j<m; j++){
						cout<<a[i][j]<<" ";
					}
					cout<<"\n";
				}
			}

			int size(){
				return n;
			}

		private:
			Row<T>* a;

	};

